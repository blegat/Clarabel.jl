var documenterSearchIndex = {"docs":
[{"location":"examples/example_QP/","page":"Basic QP Example","title":"Basic QP Example","text":"The source files for all examples can be found in /examples.","category":"page"},{"location":"examples/example_QP/","page":"Basic QP Example","title":"Basic QP Example","text":"EditURL = \"https://github.com/oxfordcontrol/Clarabel.jl/blob/main/examples/example_QP.jl\"","category":"page"},{"location":"examples/example_QP/#Basic-QP-Example","page":"Basic QP Example","title":"Basic QP Example","text":"","category":"section"},{"location":"examples/example_QP/","page":"Basic QP Example","title":"Basic QP Example","text":"Suppose that we want to solve the following 2-dimensional quadratic programming problem:","category":"page"},{"location":"examples/example_QP/","page":"Basic QP Example","title":"Basic QP Example","text":"beginarrayll textminimize   3x_1^2 + 2x_2^2 - x_1 - 4x_2\ntextsubject to   -1 leq x leq 1  x_1 = 2x_2\nendarray","category":"page"},{"location":"examples/example_QP/","page":"Basic QP Example","title":"Basic QP Example","text":"In this example we will see how to solve this problem both natively in Clarabel.jl and also by solving with Clarabel.jl within either JuMP or Convex.jl.","category":"page"},{"location":"examples/example_QP/#Clarabel.jl-native-interface","page":"Basic QP Example","title":"Clarabel.jl native interface","text":"","category":"section"},{"location":"examples/example_QP/","page":"Basic QP Example","title":"Basic QP Example","text":"To solve the problem directly within Clarabel.jl, we start by creating the solver and settings:","category":"page"},{"location":"examples/example_QP/","page":"Basic QP Example","title":"Basic QP Example","text":"using Clarabel, LinearAlgebra, SparseArrays\n\nsettings = Clarabel.Settings(verbose = true)\nsolver   = Clarabel.Solver()","category":"page"},{"location":"examples/example_QP/#Objective-function-data","page":"Basic QP Example","title":"Objective function data","text":"","category":"section"},{"location":"examples/example_QP/","page":"Basic QP Example","title":"Basic QP Example","text":"We next put the objective function into the standard Clarabel.jl form frac12x^top P x + qtop x. Define the objective function data as P = footnotesizefrac12cdot beginbmatrix 3  0  0  2endbmatrix and q = footnotesizebeginbmatrix -1  -4endbmatrix.","category":"page"},{"location":"examples/example_QP/","page":"Basic QP Example","title":"Basic QP Example","text":"P = sparse([3. 0.;0. 2.].*2)\nq = [-1., -4.]\nnothing  #hide","category":"page"},{"location":"examples/example_QP/#Constraint-data","page":"Basic QP Example","title":"Constraint data","text":"","category":"section"},{"location":"examples/example_QP/","page":"Basic QP Example","title":"Basic QP Example","text":"Finally we put the constraints into the standard Clarabel.jl form Ax + s = b, where s in mathcalK for some composite cone mathcalK.   We have 1 equality constraint and 6 inequalities, so we require the first element of s to be zero (i.e. the first constraint will correspond to the equality) and all other elements s_i ge 0.   Our condition on s is therefore s in K = 0^1 times mathbbR^4_ge 0 Define the constraint data as A = footnotesizebeginbmatrix*r 1  -2  1  0  0  1  -1  0  0  -1endbmatrix* and b= footnotesizebeginbmatrix 0  1  1  1  1 endbmatrix.","category":"page"},{"location":"examples/example_QP/","page":"Basic QP Example","title":"Basic QP Example","text":"A = sparse([1. -2.;    #<-- LHS of equality constraint\n            1.  0.;    #<-- LHS of inequality constraint (upper bound)\n            0.  1.;    #<-- LHS of inequality constraint (upper bound)\n           -1.  0.;    #<-- LHS of inequality constraint (lower bound)\n            0. -1.;    #<-- LHS of inequality constraint (lower bound)\n            ])\n\nb = [0.;        #<-- RHS of equality constraint\n     ones(4)   #<-- RHS of inequality constraints\n    ]\n\ncones =\n    [Clarabel.ZeroConeT(1),           #<--- for the equality constraint\n     Clarabel.NonnegativeConeT(4)]    #<--- for the inequality constraints\n\n\nnothing  #hide","category":"page"},{"location":"examples/example_QP/","page":"Basic QP Example","title":"Basic QP Example","text":"Finally we can populate the solver with problem data and solve","category":"page"},{"location":"examples/example_QP/","page":"Basic QP Example","title":"Basic QP Example","text":"Clarabel.setup!(solver, P, q, A, b, cones, settings)\nresult = Clarabel.solve!(solver)","category":"page"},{"location":"examples/example_QP/","page":"Basic QP Example","title":"Basic QP Example","text":"then retrieve our solution","category":"page"},{"location":"examples/example_QP/","page":"Basic QP Example","title":"Basic QP Example","text":"result.x","category":"page"},{"location":"examples/example_QP/","page":"Basic QP Example","title":"Basic QP Example","text":"tip: Tip\nThere is no constraint on the ordering of the cones that appears in cones as long as it is compatible with the ordering of the constraints as they appear in A and b.   There is also no constraint on the number of instances of each type that appear. You could, for example, define the inequalities in the above example using```julia cones =     [Clarabel.ZeroConeT(1),           #<–- for the equality constraint      Clarabel.NonnegativeConeT(2),    #<–- first half of the inequality constraints      Clarabel.NonnegativeConeT(2)]    #<–- second half of the inequality constraintsand get the same result.","category":"page"},{"location":"examples/example_QP/#Using-JuMP","page":"Basic QP Example","title":"Using JuMP","text":"","category":"section"},{"location":"examples/example_QP/","page":"Basic QP Example","title":"Basic QP Example","text":"We can solve the same problem a little more easily by using Clarabel.jl as the backend solver within JuMP. Here is the same problem again:","category":"page"},{"location":"examples/example_QP/","page":"Basic QP Example","title":"Basic QP Example","text":"using Clarabel, JuMP\n\nmodel = JuMP.Model(Clarabel.Optimizer)\nset_optimizer_attribute(model, \"verbose\", true)\n\n@variable(model, x[1:2])\n@constraint(model, x[1] == 2x[2])\n@constraint(model,  -1 .<= x .<= 1)\n@objective(model, Min, 3x[1]^2 + 2x[2]^2 - x[1] - 4x[2])\n\noptimize!(model)","category":"page"},{"location":"examples/example_QP/","page":"Basic QP Example","title":"Basic QP Example","text":"Here is the solution","category":"page"},{"location":"examples/example_QP/","page":"Basic QP Example","title":"Basic QP Example","text":"JuMP.value.(x)","category":"page"},{"location":"examples/example_QP/","page":"Basic QP Example","title":"Basic QP Example","text":"and the solver termination status again","category":"page"},{"location":"examples/example_QP/","page":"Basic QP Example","title":"Basic QP Example","text":"JuMP.termination_status(model)","category":"page"},{"location":"examples/example_QP/#Using-Convex.jl","page":"Basic QP Example","title":"Using Convex.jl","text":"","category":"section"},{"location":"examples/example_QP/","page":"Basic QP Example","title":"Basic QP Example","text":"We can likewise solve the same problem a using Clarabel.jl as the backend solver within Convex.jl.   Here is the same problem one more time:","category":"page"},{"location":"examples/example_QP/","page":"Basic QP Example","title":"Basic QP Example","text":"using Clarabel, Convex\n\nx = Variable(2)\nproblem = minimize(3square(x[1]) + 2square(x[2]) - x[1] - 4x[2])\nproblem.constraints = [x[1] == 2x[2]]\nproblem.constraints += [x >= -1; x <= 1]\nsolve!(problem, Clarabel.Optimizer; silent_solver = false)","category":"page"},{"location":"examples/example_QP/","page":"Basic QP Example","title":"Basic QP Example","text":"Here is our solution","category":"page"},{"location":"examples/example_QP/","page":"Basic QP Example","title":"Basic QP Example","text":"evaluate(x)","category":"page"},{"location":"examples/example_QP/","page":"Basic QP Example","title":"Basic QP Example","text":"and the solver termination status again","category":"page"},{"location":"examples/example_QP/","page":"Basic QP Example","title":"Basic QP Example","text":"problem.status","category":"page"},{"location":"examples/example_QP/","page":"Basic QP Example","title":"Basic QP Example","text":"warning: Warning\nNote that in the Clarabel.jl output that follows the call to solve! using Convex.jl, the problem posed to the solver has been converted to a second-order cone program with a linear objective.   You can see this because now nnz(P) == 0 (there is no quadratic term in the objective) and the solver reports two second order cone constraints.Although the solution will be the same, the required number of iterations and solve time are slightly higher.  When solving problems with quadratic objectives in Clarabel.jl, it is generally preferable to use either the  native Clarabel.jl interface or JuMP, both of which handle quadratic terms in the objective directly.","category":"page"},{"location":"examples/example_QP/","page":"Basic QP Example","title":"Basic QP Example","text":"","category":"page"},{"location":"examples/example_QP/","page":"Basic QP Example","title":"Basic QP Example","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/example_SOCP/","page":"Basic SOCP Example","title":"Basic SOCP Example","text":"The source files for all examples can be found in /examples.","category":"page"},{"location":"examples/example_SOCP/","page":"Basic SOCP Example","title":"Basic SOCP Example","text":"EditURL = \"https://github.com/oxfordcontrol/Clarabel.jl/blob/main/examples/example_SOCP.jl\"","category":"page"},{"location":"examples/example_SOCP/#Basic-SOCP-Example","page":"Basic SOCP Example","title":"Basic SOCP Example","text":"","category":"section"},{"location":"examples/example_SOCP/","page":"Basic SOCP Example","title":"Basic SOCP Example","text":"Suppose that we want to solve the following 2-dimensional optimization problem:","category":"page"},{"location":"examples/example_SOCP/","page":"Basic SOCP Example","title":"Basic SOCP Example","text":"beginarrayll textminimize  x_2^22ex\ntextsubject to   leftbeginpmatrix 2x_1  x_2 endpmatrix\n- beginpmatrix 2  2 endpmatrixright_2 le 1\nendarray","category":"page"},{"location":"examples/example_SOCP/","page":"Basic SOCP Example","title":"Basic SOCP Example","text":"In this example we will see how to solve this problem both natively in Clarabel.jl and also by solving with Clarabel.jl within JuMP.","category":"page"},{"location":"examples/example_SOCP/#Clarabel.jl-native-interface","page":"Basic SOCP Example","title":"Clarabel.jl native interface","text":"","category":"section"},{"location":"examples/example_SOCP/","page":"Basic SOCP Example","title":"Basic SOCP Example","text":"To solve the problem directly within Clarabel.jl, we start by creating the solver and settings:","category":"page"},{"location":"examples/example_SOCP/","page":"Basic SOCP Example","title":"Basic SOCP Example","text":"using Clarabel, LinearAlgebra, SparseArrays\n\nsettings = Clarabel.Settings(verbose = true)\nsolver   = Clarabel.Solver()","category":"page"},{"location":"examples/example_SOCP/#Objective-function-data","page":"Basic SOCP Example","title":"Objective function data","text":"","category":"section"},{"location":"examples/example_SOCP/","page":"Basic SOCP Example","title":"Basic SOCP Example","text":"We next put the objective function into the standard Clarabel.jl form frac12x^top P x + qtop x. Define the objective function data as","category":"page"},{"location":"examples/example_SOCP/","page":"Basic SOCP Example","title":"Basic SOCP Example","text":"P = sparse([0. 0.;0. 1.].*2)\nq = [0., 0.]\nnothing  #hide","category":"page"},{"location":"examples/example_SOCP/#Constraint-data","page":"Basic SOCP Example","title":"Constraint data","text":"","category":"section"},{"location":"examples/example_SOCP/","page":"Basic SOCP Example","title":"Basic SOCP Example","text":"Finally we put the constraints into the standard Clarabel.jl form Ax + s = b, where s in mathcalK for some  cone mathcalK.  We have a single constraint on the 2-norm of a vector, so we rewrite","category":"page"},{"location":"examples/example_SOCP/","page":"Basic SOCP Example","title":"Basic SOCP Example","text":"leftbeginpmatrix 2x_1  x_2 endpmatrix - beginpmatrix 2  2 endpmatrixright_2 le 1\nquad Longleftrightarrow quad\nbeginpmatrix 1  2x_1 - 2 x_2 - 2 endpmatrix in mathcalK_SOC","category":"page"},{"location":"examples/example_SOCP/","page":"Basic SOCP Example","title":"Basic SOCP Example","text":"which puts our constraint in the form b - Ax in mathcalK_SOC.  We therefore define the constraint data as","category":"page"},{"location":"examples/example_SOCP/","page":"Basic SOCP Example","title":"Basic SOCP Example","text":"A = sparse([0.  0.\n           -2.  0.;\n            0. -1.])\nb = [ 1.\n     -2.;\n     -2.]\n\ncones = [Clarabel.SecondOrderConeT(3)]\n\nnothing  #hide","category":"page"},{"location":"examples/example_SOCP/","page":"Basic SOCP Example","title":"Basic SOCP Example","text":"Finally we can populate the solver with problem data and solve","category":"page"},{"location":"examples/example_SOCP/","page":"Basic SOCP Example","title":"Basic SOCP Example","text":"Clarabel.setup!(solver, P, q, A, b, cones, settings)\nresult = Clarabel.solve!(solver)","category":"page"},{"location":"examples/example_SOCP/","page":"Basic SOCP Example","title":"Basic SOCP Example","text":"then retrieve our solution","category":"page"},{"location":"examples/example_SOCP/","page":"Basic SOCP Example","title":"Basic SOCP Example","text":"result.x","category":"page"},{"location":"examples/example_SOCP/#Using-JuMP","page":"Basic SOCP Example","title":"Using JuMP","text":"","category":"section"},{"location":"examples/example_SOCP/","page":"Basic SOCP Example","title":"Basic SOCP Example","text":"We can solve the same problem using Clarabel.jl as the backend solver within JuMP. Here is the same problem again:","category":"page"},{"location":"examples/example_SOCP/","page":"Basic SOCP Example","title":"Basic SOCP Example","text":"using Clarabel, JuMP\n\nmodel = JuMP.Model(Clarabel.Optimizer)\nset_optimizer_attribute(model, \"verbose\", true)\n\n@variable(model, x[1:2])\n@constraint(model, [1, 2x[1]-2, x[2] - 2] in SecondOrderCone())\n@objective(model, Min, x[2]^2 )\n\noptimize!(model)","category":"page"},{"location":"examples/example_SOCP/","page":"Basic SOCP Example","title":"Basic SOCP Example","text":"Here is the solution","category":"page"},{"location":"examples/example_SOCP/","page":"Basic SOCP Example","title":"Basic SOCP Example","text":"JuMP.value.(x)","category":"page"},{"location":"examples/example_SOCP/","page":"Basic SOCP Example","title":"Basic SOCP Example","text":"and the solver termination status again","category":"page"},{"location":"examples/example_SOCP/","page":"Basic SOCP Example","title":"Basic SOCP Example","text":"JuMP.termination_status(model)","category":"page"},{"location":"examples/example_SOCP/#Using-Convex.jl","page":"Basic SOCP Example","title":"Using Convex.jl","text":"","category":"section"},{"location":"examples/example_SOCP/","page":"Basic SOCP Example","title":"Basic SOCP Example","text":"One more time using Clarabel.jl as the backend solver within Convex.jl:","category":"page"},{"location":"examples/example_SOCP/","page":"Basic SOCP Example","title":"Basic SOCP Example","text":"using Clarabel, Convex\n\nx = Variable(2)\nproblem = minimize(square(x[2]))\nproblem.constraints = [norm([2x[1];x[2]] - [2;2], 2) <= 1]\nsolve!(problem, Clarabel.Optimizer; silent_solver = false)","category":"page"},{"location":"examples/example_SOCP/","page":"Basic SOCP Example","title":"Basic SOCP Example","text":"Here is our solution","category":"page"},{"location":"examples/example_SOCP/","page":"Basic SOCP Example","title":"Basic SOCP Example","text":"evaluate(x)","category":"page"},{"location":"examples/example_SOCP/","page":"Basic SOCP Example","title":"Basic SOCP Example","text":"and the solver termination status again","category":"page"},{"location":"examples/example_SOCP/","page":"Basic SOCP Example","title":"Basic SOCP Example","text":"problem.status","category":"page"},{"location":"examples/example_SOCP/","page":"Basic SOCP Example","title":"Basic SOCP Example","text":"","category":"page"},{"location":"examples/example_SOCP/","page":"Basic SOCP Example","title":"Basic SOCP Example","text":"This page was generated using Literate.jl.","category":"page"},{"location":"contributing/#Contributing","page":"Contributing","title":"Contributing","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Contributions are always welcome:","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Please report any issues and bugs that you encounter in Issues\nAs an open source project we are also interested in any projects and applications that use Clarabel.jl. Please let us know via email to: paul.goulart@eng.ox.ac.uk","category":"page"},{"location":"literate/build/convex_jl/","page":"Convex.jl Interface","title":"Convex.jl Interface","text":"EditURL = \"https://github.com/oxfordcontrol/Clarabel.jl/blob/main/docs/src/literate/convex_jl.jl\"","category":"page"},{"location":"literate/build/convex_jl/#Convex.jl-Interface","page":"Convex.jl Interface","title":"Convex.jl Interface","text":"","category":"section"},{"location":"literate/build/convex_jl/","page":"Convex.jl Interface","title":"Convex.jl Interface","text":"Clarabel.jl implements support for MathOptInterface, and is therefore compatible with Convex.jl.   This allows you to describe and modify your optimisation problem with Convex.jl and use Clarabel as the backend solver.","category":"page"},{"location":"literate/build/convex_jl/#Setting-Clarabel.jl-Backend","page":"Convex.jl Interface","title":"Setting Clarabel.jl Backend","text":"","category":"section"},{"location":"literate/build/convex_jl/","page":"Convex.jl Interface","title":"Convex.jl Interface","text":"You should construct your problem in the usual way in Convex.jl, and then solve using Clarabel.Optimizer, i.e. by calling solve! with","category":"page"},{"location":"literate/build/convex_jl/","page":"Convex.jl Interface","title":"Convex.jl Interface","text":"solve!(problem, Clarabel.Optimizer)","category":"page"},{"location":"literate/build/convex_jl/","page":"Convex.jl Interface","title":"Convex.jl Interface","text":"where problem is an object of type Convex.Problem.","category":"page"},{"location":"literate/build/convex_jl/#Convex.jl-or-JuMP?","page":"Convex.jl Interface","title":"Convex.jl or JuMP?","text":"","category":"section"},{"location":"literate/build/convex_jl/","page":"Convex.jl Interface","title":"Convex.jl Interface","text":"Clarabel.jl supports both Convex.jl and JuMP via MathOptInterface.   Both packages are excellent and can make problem construction considerably easier than via the solver's native interface.","category":"page"},{"location":"literate/build/convex_jl/","page":"Convex.jl Interface","title":"Convex.jl Interface","text":"For problems with quadratic objective functions, JuMP is generally preferred when using Clarabel.jl since it will keep the quadratic function in the objective rather than reformulating the problem to a form with a linear cost and additional second-order cone constraints.   Clarabel.jl natively supports quadratic objectives and solve times are generally faster if this reformulation is avoided.","category":"page"},{"location":"literate/build/convex_jl/#Arbitrary-Precision-Arithmetic","page":"Convex.jl Interface","title":"Arbitrary Precision Arithmetic","text":"","category":"section"},{"location":"literate/build/convex_jl/","page":"Convex.jl Interface","title":"Convex.jl Interface","text":"Clarabel.jl supports arbitary precision arithmetic for Convex.jl.   Here is the Basic QP Example implemented using BigFloat types.","category":"page"},{"location":"literate/build/convex_jl/","page":"Convex.jl Interface","title":"Convex.jl Interface","text":"#hide setprecision(BigFloat,256)\nusing Clarabel, Convex\n\nx = Variable(2)\nobjective = 3square(x[1]) + 2square(x[2]) - x[1] - 4x[2]\nproblem = minimize(objective; numeric_type = BigFloat)\nproblem.constraints = [x[1] == 2x[2]]\nproblem.constraints += [x >= -1; x <= 1]\nsolve!(problem, Clarabel.Optimizer{BigFloat}; silent_solver = false)","category":"page"},{"location":"literate/build/convex_jl/","page":"Convex.jl Interface","title":"Convex.jl Interface","text":"","category":"page"},{"location":"literate/build/convex_jl/","page":"Convex.jl Interface","title":"Convex.jl Interface","text":"This page was generated using Literate.jl.","category":"page"},{"location":"linear_solvers/#Linear-System-Solvers","page":"Linear Solvers","title":"Linear System Solvers","text":"","category":"section"},{"location":"linear_solvers/","page":"Linear Solvers","title":"Linear Solvers","text":"The primary numerical operation inside Clarabel.jl is the solution of a symmetric quasidefinite linear system at each iteration.  The solver currently supports two different solvers to perform factorization and forward/backward substitution on this system.","category":"page"},{"location":"linear_solvers/","page":"Linear Solvers","title":"Linear Solvers","text":"The linear solver can be configured in Settings using the direct_solve_method field, e.g.","category":"page"},{"location":"linear_solvers/","page":"Linear Solvers","title":"Linear Solvers","text":"settings = Solver.Settings(direct_solve_method = :qdldl)","category":"page"},{"location":"linear_solvers/","page":"Linear Solvers","title":"Linear Solvers","text":"The solvers currently supported are","category":"page"},{"location":"linear_solvers/","page":"Linear Solvers","title":"Linear Solvers","text":"Symbol Package Description\n:qdldl QDLDL.jl Default solver\n:mkl Pardiso.jl Intel MKL Pardiso\n:cholmod Julia native ldlt solver SuiteSparse.CHOLMOD","category":"page"},{"location":"linear_solvers/","page":"Linear Solvers","title":"Linear Solvers","text":"note: Note\nTo use the MKL Pardiso solver you must install the respective libraries and the corresponding Julia wrapper. For more information about installing these, visit the Pardiso.jl repository page.","category":"page"},{"location":"linear_solvers/","page":"Linear Solvers","title":"Linear Solvers","text":"QDLDL is a single threaded solver written in pure Julia, and is generally adequate for problems of small to medium size.   The MKL Pardiso solver is multi-threaded and may be preferred for very large problem instances, or problems in which the problem data is extremely dense.","category":"page"},{"location":"linear_solvers/","page":"Linear Solvers","title":"Linear Solvers","text":"Support for additional linear system solvers may be implemented in future releases.   ","category":"page"},{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/#api-solver","page":"API Reference","title":"Solver and main API","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Clarabel.Solver\nClarabel.setup!\nClarabel.solve!","category":"page"},{"location":"api/#Clarabel.Solver","page":"API Reference","title":"Clarabel.Solver","text":"Solver{T <: AbstractFloat}()\n\nInitializes an empty Clarabel solver that can be filled with problem data using:\n\nsetup!(solver, P, q, A, b, cones, [settings]).\n\n\n\n\n\n","category":"type"},{"location":"api/#Clarabel.setup!","page":"API Reference","title":"Clarabel.setup!","text":"setup!(solver, P, q, A, b, cones, [settings])\n\nPopulates a Solver with a cost function defined by P and q, and one or more conic constraints defined by A, b and a description of a conic constraint composed of cones whose types and dimensions are specified by cones.\n\nThe solver will be configured to solve the following optimization problem:\n\nmin   1/2 x'Px + q'x\ns.t.  Ax + s = b, s ∈ K\n\nAll data matrices must be sparse.   The matrix P is assumed to be symmetric and positive semidefinite, and only the upper triangular part is used.\n\nThe cone K is a composite cone.   To define the cone the user should provide a vector of cone specifications along with the appropriate dimensional information.   For example, to generate a cone in the nonnegative orthant followed by a second order cone, use:\n\ncones = [Clarabel.NonnegativeConeT(dim_1),\n         Clarabel.SecondOrderConeT(dim_2)]\n\nIf the argument 'cones' is constructed incrementally, the should should initialize it as an empty array of the supertype for all allowable cones, e.g.\n\ncones = Clarabel.SupportedCone[]\npush!(cones,Clarabel.NonnegativeConeT(dim_1))\n...\n\nThe optional argument settings can be used to pass custom solver settings:\n\nsettings = Clarabel.Settings(verbose = true)\nsetup!(model, P, q, A, b, cones, settings)\n\nTo solve the problem, you must make a subsequent call to solve!\n\n\n\n\n\n","category":"function"},{"location":"api/#Clarabel.solve!","page":"API Reference","title":"Clarabel.solve!","text":"solve!(solver)\n\nComputes the solution to the problem in a Clarabel.Solver previously defined in setup!.\n\n\n\n\n\n","category":"function"},{"location":"api/#api-cones","page":"API Reference","title":"Supported Cone Types","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Clarabel.SupportedCone","category":"page"},{"location":"api/#Clarabel.SupportedCone","page":"API Reference","title":"Clarabel.SupportedCone","text":"SupportedCone\n\nAn abstract type use by the Clarabel API used when passing cone specifications to the solver setup!. The currently supported concrete types are:\n\nZeroConeT       : The zero cone.  Used to define equalities.\nNonnegativeConeT: The nonnegative orthant.\nSecondOrderConeT: The second order / Lorentz / ice-cream cone.\n\nPSDTriangleConeT: The positive semidefinite cone (triangular format).\n\n\n\n\n\n","category":"type"},{"location":"api/#api-settings","page":"API Reference","title":"Settings","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Clarabel.Settings","category":"page"},{"location":"api/#Clarabel.Settings","page":"API Reference","title":"Clarabel.Settings","text":"Clarabel.Settings{T}(kwargs) where {T <: AbstractFloat}\n\nCreates a Clarabel Settings object that is used to pass user settings to the solver.\n\nArgument Default Value Description\n  \nMain Algorithm Settings  \n  \nmax_iter 50 maximum number of iterations\ntime_limit 0 maximum run time (seconds)\nverbose true verbose printing\ntol_gap_abs 1e-8 absolute residual tolerance\ntol_gap_rel 1e-8 relative residual tolerance\ntol_feas 1e-5 feasibility check tolerance\ntol\\infeas\\abs 1e-8 absolute infeasibility tolerance\ntol\\infeas\\rel 1e-8 relative infeasibility tolerance\nmax_step_fraction 0.99 maximum interior point step length\n  \nData Equilibration Settings  \n  \nequilibrate_enable true enable  data equilibration pre-scaling\nequilibrate_max_iter 10 maximum equilibration scaling iterations\nequilibrate_min_scaling 1e-4 minimum equilibration scaling allowed\nequilibrate_max_scaling 1e+4 maximum equilibration scaling allowed\n  \nLinear Solver Settings  \n  \ndirect_kkt_solver true use a direct linear solver method (required true)\ndirect_solve_method :qdldl direct linear solver (:qdldl, :mkl or :cholmod)\nstatic_regularization_enable true enable KKT static regularization\nstatic_regularization_eps 1e-8 KKT static regularization parameter\ndynamic_regularization_enable true enable KKT dynamic regularization\ndynamic_regularization_eps 1e-13 KKT dynamic regularization threshold\ndynamic_regularization_delta 2e-7 KKT dynamic regularization shift\niterative_refinement_enable true KKT solve with iterative refinement\niterative_refinement_reltol 1e-10 iterative refinement relative tolerance\niterative_refinement_abstol 1e-10 iterative refinement absolute tolerance\niterative_refinement_max_iter 10 iterative refinement maximum iterations\niterative_refinement_stop_ratio 2.0 iterative refinement stalling tolerance\n\n\n\n\n\n","category":"type"},{"location":"api/#api-solverstatus","page":"API Reference","title":"Solver Status","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Clarabel.SolverStatus","category":"page"},{"location":"api/#Clarabel.SolverStatus","page":"API Reference","title":"Clarabel.SolverStatus","text":"SolverStatus\n\nAn Enum of of possible conditions set by solve!.\n\nIf no call has been made to solve!, then the SolverStatus is:\n\nUNSOLVED: The algorithm has not started.\n\nOtherwise:\n\nSOLVED              : Solver as terminated with a solution.\nPRIMAL_INFEASIBLE   : Problem is primal infeasible.  Solution returned is a certificate of primal infeasibility.\nDUAL_INFEASIBLE     : Problem is dual infeasible.  Solution returned is a certificate of dual infeasibility.\nMAX_ITERATIONS      : Iteration limit reached before solution or infeasibility certificate found.\nMAX_TIME            : Time limit reached before solution or infeasibility certificate found.\n\n\n\n\n\n","category":"type"},{"location":"literate/build/arbitrary_precision/","page":"Arbitrary Precision Arithmetic","title":"Arbitrary Precision Arithmetic","text":"EditURL = \"https://github.com/oxfordcontrol/Clarabel.jl/blob/main/docs/src/literate/arbitrary_precision.jl\"","category":"page"},{"location":"literate/build/arbitrary_precision/#Arbitrary-Precision-Arithmetic","page":"Arbitrary Precision Arithmetic","title":"Arbitrary Precision Arithmetic","text":"","category":"section"},{"location":"literate/build/arbitrary_precision/","page":"Arbitrary Precision Arithmetic","title":"Arbitrary Precision Arithmetic","text":"Clarabel.jl supports the use of arbitrary precision floating-point types, including Julia's BigFloat type.  To use this feature you must specify all of your problem data using a common floating point type and explictly create Clarabel.Solver and (optional) Clarabel.Settings objects of the the same type.","category":"page"},{"location":"literate/build/arbitrary_precision/","page":"Arbitrary Precision Arithmetic","title":"Arbitrary Precision Arithmetic","text":"Start by creating the solver and settings with the desired precision:","category":"page"},{"location":"literate/build/arbitrary_precision/","page":"Arbitrary Precision Arithmetic","title":"Arbitrary Precision Arithmetic","text":"using Clarabel, LinearAlgebra, SparseArrays\n\nsettings = Clarabel.Settings{BigFloat}(\n            verbose = true,\n            direct_kkt_solver = true,\n            direct_solve_method = :qdldl)\n\nsolver   = Clarabel.Solver{BigFloat}()","category":"page"},{"location":"literate/build/arbitrary_precision/#Objective-and-constraint-data","page":"Arbitrary Precision Arithmetic","title":"Objective and constraint data","text":"","category":"section"},{"location":"literate/build/arbitrary_precision/","page":"Arbitrary Precision Arithmetic","title":"Arbitrary Precision Arithmetic","text":"We next put the objective function into the standard Clarabel.jl form.   Here we use the same problem data as in the Basic QP Example, but in BigFloat format :","category":"page"},{"location":"literate/build/arbitrary_precision/","page":"Arbitrary Precision Arithmetic","title":"Arbitrary Precision Arithmetic","text":"P = sparse(BigFloat[3. 0.;0. 2.].*2)\nq = BigFloat[-1., -4.]\nA = sparse(\n    BigFloat[1. -2.;    #<-- LHS of equality constraint\n             1.  0.;    #<-- LHS of inequality constraint (upper bound)\n             0.  1.;    #<-- LHS of inequality constraint (upper bound)\n            -1.  0.;    #<-- LHS of inequality constraint (lower bound)\n             0. -1.;    #<-- LHS of inequality constraint (lower bound)\n    ])\nb = [zero(BigFloat);    #<-- RHS of equality constraint\n     ones(BigFloat,4)   #<-- RHS of inequality constraints\n    ]\n\ncones =\n    [Clarabel.ZeroConeT(1),           #<--- for the equality constraint\n     Clarabel.NonnegativeConeT(4)]    #<--- for the inequality constraints\n\nnothing  #hide","category":"page"},{"location":"literate/build/arbitrary_precision/","page":"Arbitrary Precision Arithmetic","title":"Arbitrary Precision Arithmetic","text":"You can optionally set the global precision of Julia's BigFloat type before solving","category":"page"},{"location":"literate/build/arbitrary_precision/","page":"Arbitrary Precision Arithmetic","title":"Arbitrary Precision Arithmetic","text":"setprecision(BigFloat,128)\nnothing  #hide","category":"page"},{"location":"literate/build/arbitrary_precision/","page":"Arbitrary Precision Arithmetic","title":"Arbitrary Precision Arithmetic","text":"Finally we can set up the problem in the usual way and solve","category":"page"},{"location":"literate/build/arbitrary_precision/","page":"Arbitrary Precision Arithmetic","title":"Arbitrary Precision Arithmetic","text":"Clarabel.setup!(solver, P, q, A, b, cones, settings)\nresult = Clarabel.solve!(solver)\n\n#then retrieve the solution\n\nresult.x","category":"page"},{"location":"literate/build/arbitrary_precision/","page":"Arbitrary Precision Arithmetic","title":"Arbitrary Precision Arithmetic","text":"Notice that the above would fail if the default solver was used, because Clarabel.jl uses Float64 by default","category":"page"},{"location":"literate/build/arbitrary_precision/","page":"Arbitrary Precision Arithmetic","title":"Arbitrary Precision Arithmetic","text":"Clarabel.Solver()","category":"page"},{"location":"literate/build/arbitrary_precision/","page":"Arbitrary Precision Arithmetic","title":"Arbitrary Precision Arithmetic","text":"warning: Warning\nFor arbitrary precision arithmetic using BigFloat types you must select an internal linear solver within Clarabel.jl that supports it.   We recommend that you use the QDLDL.jl package for such problems, and configure it as the linear solver by setting both direct_kkt_solver = true and direct_solve_method = :qdldl in the Settings object.","category":"page"},{"location":"literate/build/arbitrary_precision/#With-Convex.jl-/-JuMP","page":"Arbitrary Precision Arithmetic","title":"With Convex.jl / JuMP","text":"","category":"section"},{"location":"literate/build/arbitrary_precision/","page":"Arbitrary Precision Arithmetic","title":"Arbitrary Precision Arithmetic","text":"Clarabel.jl also supports arbitrary precision arithmetic through Convex.jl.   See the example in the Convex.jl Interface section.","category":"page"},{"location":"literate/build/arbitrary_precision/","page":"Arbitrary Precision Arithmetic","title":"Arbitrary Precision Arithmetic","text":"note: Note\nJuMP does not currently support arbitrary precision. However, if you want to use Clarabel directly with MathOptInterface, you can use: Clarabel.Optimizer{<: AbstractFloat} as your optimizer.  As above, the problem data precision of your MathOptInterface-model must agree with the optimizer's precision.","category":"page"},{"location":"literate/build/arbitrary_precision/","page":"Arbitrary Precision Arithmetic","title":"Arbitrary Precision Arithmetic","text":"","category":"page"},{"location":"literate/build/arbitrary_precision/","page":"Arbitrary Precision Arithmetic","title":"Arbitrary Precision Arithmetic","text":"This page was generated using Literate.jl.","category":"page"},{"location":"jump/#JuMP-Interface","page":"JuMP Interface","title":"JuMP Interface","text":"","category":"section"},{"location":"jump/","page":"JuMP Interface","title":"JuMP Interface","text":"Clarabel.jl implements support for MathOptInterface, and is therefore compatible with JuMP.   This allows you to describe and modify your optimisation problem with JuMP and use Clarabel.jl as the backend solver.","category":"page"},{"location":"jump/#Setting-Clarabel.jl-Backend","page":"JuMP Interface","title":"Setting Clarabel.jl Backend","text":"","category":"section"},{"location":"jump/","page":"JuMP Interface","title":"JuMP Interface","text":"To specify Clarabel.jl as the solver for your JuMP model, load the solver module with using Clarabel and then configure Clarabel as the solver backend when initialising the JuMP model:","category":"page"},{"location":"jump/","page":"JuMP Interface","title":"JuMP Interface","text":"model = JuMP.Model(Clarabel.Optimizer)","category":"page"},{"location":"jump/#Solver-Settings","page":"JuMP Interface","title":"Solver Settings","text":"","category":"section"},{"location":"jump/","page":"JuMP Interface","title":"JuMP Interface","text":"Solver-specific settings can be passed after the Clarabel.Optimizer object. For example, if you want to adjust the maximum number of iterations and turn off verbose printing use","category":"page"},{"location":"jump/","page":"JuMP Interface","title":"JuMP Interface","text":"set_optimizer_attribute(model, \"verbose\", true)\nset_optimizer_attribute(model, \"max_iter\", 25)","category":"page"},{"location":"jump/","page":"JuMP Interface","title":"JuMP Interface","text":"The full list of available settings can be found in the Settings section of the API Reference.","category":"page"},{"location":"jump/#Results","page":"JuMP Interface","title":"Results","text":"","category":"section"},{"location":"jump/","page":"JuMP Interface","title":"JuMP Interface","text":"After solving the problem the result can be obtained using the standard JuMP commands. To see if the optimisation was successful use","category":"page"},{"location":"jump/","page":"JuMP Interface","title":"JuMP Interface","text":"JuMP.termination_status(model)\nJuMP.primal_status(model)","category":"page"},{"location":"jump/","page":"JuMP Interface","title":"JuMP Interface","text":"If a solution is available, the optimal objective value can be retrieved using","category":"page"},{"location":"jump/","page":"JuMP Interface","title":"JuMP Interface","text":"JuMP.objective_value(model)","category":"page"},{"location":"jump/","page":"JuMP Interface","title":"JuMP Interface","text":"and the value of a decision variable x can be obtained with","category":"page"},{"location":"jump/","page":"JuMP Interface","title":"JuMP Interface","text":"JuMP.value.(x)","category":"page"},{"location":"jump/","page":"JuMP Interface","title":"JuMP Interface","text":"For more information on JuMP, see the JuMP documentation.","category":"page"},{"location":"getting_started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"This guide describes the process of creating a Clarabel.jl model, populating its settings and problem data, solving the problem and obtaining and understanding results.  The description here relates to Clarabel's native API.  If you want to use JuMP or Convex.jl to model your  problem instead, see the JuMP Interface and Convex.jl Interface sections.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Clarabel.jl solves optimisation problems in the format:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"beginarrayll textminimize  textstylefrac12x^top Px + q^top x textsubject to  Ax + s = b   s in mathcalK endarray","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"with decision variables x in mathbbR^n, s in mathbbR^m and data matrices P=P^top succeq 0, q in mathbbR^n, A in mathbbR^m times n, and b in mathbbR^m.  The convex cone mathcalK is a composition of smaller convex cones mathcalK = mathcalK_1 times mathcalK_2  dots mathcalK_p.   Equality conditions can be modelled in this format using the solver's ZeroCone type.   ","category":"page"},{"location":"getting_started/#Making-a-Solver","page":"Getting Started","title":"Making a Solver","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"The problem data, user settings and workspace variables are all stored in a top level Solver type. To get started define an empty Solver:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"using Clarabel\nmodel = Clarabel.Solver()","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"It is also possible to specify one or more solver configuration settings at creation time.   See the [Settings][@ref] section below.   ","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"To initialize the solver with an optimisation problem we require three more things:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"The objective function, i.e. the matrix P and the vector q in frac12x^top P x + q^top x\nThe data matrix A and vector b, along with a description of the composite cone \\mathcal{K} and the dimensions of its constituent pieces.\nA Settings object that specifies how Clarabel.jl solves the problem (optional)","category":"page"},{"location":"getting_started/#Settings","page":"Getting Started","title":"Settings","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Solver settings are stored in a Settings object and can be modified by the user. To create a Settings object just call the constructor:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"settings = Clarabel.Settings()","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"To adjust those values, you can pass options and parameters as a key-value pair to the constructor or edit the corresponding field afterwards. For example, if you want to disable verbose printing and set a 5 second time limit on the solver, you can use","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"settings = Clarabel.Settings(verbose = false, time_limit = 5)\n\n# the following is equivalent\nsettings = Clarabel.Settings()\nsettings.verbose    = false\nsettings.time_limit = 5","category":"page"},{"location":"getting_started/#Objective-Function","page":"Getting Started","title":"Objective Function","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"To set the objective function of your optimisation problem simply define the square positive semidefinite matrix P in mathrmR^ntimes n and the vector q in mathrmR^n. Clarabel.jl expects the P matrix to be supplied in sparse format.   The matrix P is assumed by the solver to be symmetric and only values in the upper triangular part of P are needed by the solver.","category":"page"},{"location":"getting_started/#Constraints","page":"Getting Started","title":"Constraints","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"The Clarabel.jl interface expects constraints to be presented in the single vectorized form Ax + s = b s in mathcalK, where mathcalK = mathcalK_1 times dots times mathcalK_p and each mathcalK_i is one of the  cones defined below:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Cone Type Description\nZeroConeT The set  0 ^dim that contains the origin\nNonnegativeConeT The nonnegative orthant  x in mathbbR^dim  x_i ge 0 forall i=1dotsmathrmdim \nSecondOrderConeT The second-order (Lorenz) cone  (tx) in mathbbR^dim    x_2   leq t ","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Suppose that we have a problem with decision variable x in mathbbR^3 and our constraints are:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"A single equality constraint x_1 + x_2 - x_3 = 1.   \nA pair of inequalities such that x_2 and x_3 are each less than 2.\nA second order cone constraint on the 3-dimensional vector x.   ","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"We can then define our constraint data as","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"using SparseArrays\n\n# equality constraint\nAeq = [1 1 -1]\nbeq = [1]\n\n# inequality constraint\nAineq = [0 1 0;\n         0 0 1]\nbineq = [2,2]\n\n# SOC constraint\nAsoc = -I(3)\nbsoc = [0,0,0]\n\n#Clarabel.jl constraint data\nA = sparse([Aeq; Aineq; Asoc])\nb = [beq;bineq;bsoc]","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Clarabel.jl expects to receive a vector of cone specifications.  For the above constraints we  should also define","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"#Clarabel.jl cone specification\ncones = [Clarabel.ZeroConeT(1), Clarabel.NonnegativeConeT(2), SecondOrderConeT(3)]","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"note: Note\nThe cones cones' should be of typeVector{Clarabel.SupportedCone}, and your input vectorb` should be compatible with the sum of the cone dimensions.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"note: Note\nNote carefully the signs in the above example.   The inequality condition is A_ineq x le b_ineq, which is equivalent to A_ineq x + s = b_ineq with s ge 0, i.e. s in the Nonnegative cone.    The SOC condition is x in mathcalK_SOC, or equivalently -x + s = 0 with s in mathcalK_SOC.","category":"page"},{"location":"getting_started/#Adding-problem-data","page":"Getting Started","title":"Adding problem data","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Once the objective function and an array of constraints have been defined, you can provide the solver with problem data using","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Clarabel.setup!(solver, P, q, A, b, cones, settings)","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"This takes an internal copy of all data parameters and initializes internal variables and other objects in the solver.  The final settings argument is optional.","category":"page"},{"location":"getting_started/#Solving","page":"Getting Started","title":"Solving","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Now you can solve it using:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"result = Clarabel.solve!(solver)","category":"page"},{"location":"getting_started/#Results","page":"Getting Started","title":"Results","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Once the solver algorithm terminates you can inspect the solution using the result object and the result.info fields.   The primal solution will be in result.x and the dual solution in result.z. The outcome of the solve is specified in result.status and will be one of the following :","category":"page"},{"location":"getting_started/#Status-Codes","page":"Getting Started","title":"Status Codes","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Status Code Description\nUNSOLVED Default value, only occurs prior to calling Clarabel.solve!\nSOLVED Solution found\nPRIMAL_INFEASIBLE Problem is primal infeasible\nDUAL_INFEASIBLE Problem is dual infeasible\nMAX_ITERATIONS Solver halted after reaching iteration limit\nMAX_TIME Solver halted after reaching time limit","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"The total solution time (include combined setup! and solve! times) is given in result.info.solve_time.   Detailed information about the solve time and memory allocation can be found in result.info.timer.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"warning: Warning\nBe careful to retrieve solver solutions from the result that is returned by the solver, or directly from a solver object from the solver.result field.   Do not use the solver.variables, since these have both homogenization and equilibration scaling applied and therefore do not solve the optimization problem posed to the solver.","category":"page"},{"location":"getting_started/#Settings-2","page":"Getting Started","title":"Settings","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"The full set of user configurable solver settings are listed in the API Reference","category":"page"},{"location":"","page":"Home","title":"Home","text":"Clarabel.jl is a Julia implementation of an interior point numerical solver for convex optimization problems using a novel homogeneous embedding.  Clarabel.jl solves the following problem:","category":"page"},{"location":"","page":"Home","title":"Home","text":"beginarrayll textminimize  textstylefrac12x^top Px + q^top x textsubject to  Ax + s = b   s in mathcalK\nendarray","category":"page"},{"location":"","page":"Home","title":"Home","text":"with decision variables x in mathbbR^n, s in mathbbR^m and data matrices P=P^top succeq 0, q in mathbbR^n, A in mathbbR^m times n, and b in mathbbR^m. The convex set mathcalK is a composition of convex cones.","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Versatile: Clarabel.jl solves linear programs (LPs), quadratic programs (QPs), second-order cone programs (SOCPs) and semidefinite programs (SDPs).  Future versions will provide support for problems involving exponential and power cones.\nQuadratic objectives: Unlike interior point solvers based on the standard homogeneous self-dual embedding (HSDE) model, Clarabel.jl handles quadratic objective without requiring any epigraphical reformulation of its objective function.   It can therefore be significantly faster than other HSDE-based solvers for problems with quadratic objective functions.\nInfeasibility detection: Infeasible problems are detected using using a homogeneous embedding technique.\nJuMP / Convex.jl support: We provide an interface to MathOptInterface (MOI), which allows you to describe your problem in JuMP and Convex.jl.\nArbitrary precision types: You can solve problems with any floating point precision, e.g. Float32 or Julia's BigFloat type, using either the native interface, or via MathOptInterface / Convex.jl.\nOpen Source: Our code is available on GitHub and distributed under the Apache 2.0 Licence.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Clarabel.jl can be installed using the Julia package manager for Julia v1.0 and higher. Inside the Julia REPL, type ] to enter the Pkg REPL mode then run","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add Clarabel","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you want to install the latest version from the github repository run","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add Clarabel#main","category":"page"},{"location":"#Credits","page":"Home","title":"Credits","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The following people are involved in the development of Clarabel.jl:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Paul Goulart (main development, maths and algorithms)\nYuwen Chen (maths and algorithms)","category":"page"},{"location":"","page":"Home","title":"Home","text":"All contributors are affiliated with the Control Group of the Department of Engineering Science at the University of Oxford.","category":"page"},{"location":"","page":"Home","title":"Home","text":"If this project is useful for your work please consider","category":"page"},{"location":"","page":"Home","title":"Home","text":"Citing the relevant papers\nLeaving a star on the GitHub repository","category":"page"},{"location":"#Licence","page":"Home","title":"Licence","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Clarabel.jl is licensed under the Apache License 2.0. For more details click here.","category":"page"},{"location":"citing/","page":"Citing Clarabel","title":"Citing Clarabel","text":"A paper describing the Clarabel solver algorithm and implementation will be forthcoming soon.   Until then, we ask that you cite this documentation if you have found Clarabel.jl useful in your work.","category":"page"}]
}
